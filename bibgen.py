"""Parse all BibTeX files and generate Markdown for each entry."""

import bibtexparser
import glob
import os
import re

WARN = "<!-- DO NOT EDIT THIS FILE (automatically generated by bibgen.py) -->"


def reformat_authors(author_string):
    """Convert author string to "First Last" format, separated by commas."""
    authors = author_string.split(" and ")
    reformatted = []
    for author in authors:
        if "," in author:
            last, first = [part.strip() for part in author.split(",", 1)]
            reformatted.append(f"{first} {last}")
        else:
            # Already in "First Last" format
            reformatted.append(author.strip())
    return ", ".join(reformatted)


def bib2md(path, entry):
    """Generate a Markdown file for the entry."""

    # Extract the most common fields
    title = entry.fields_dict["title"].value
    author = entry.fields_dict["author"].value
    year = entry.fields_dict["year"].value
    source = ""
    for fkey in ["booktitle", "journal", "publisher", "howpublished", "url"]:
        if fkey in entry.fields_dict:
            source = entry.fields_dict[fkey].value
            break

    # Create a reference format string
    author = reformat_authors(author)
    if source:
        source = f"*{source}*."
        if entry.entry_type.startswith("in"):
            source = "In " + source
    ref = f"{author}. ({year}). {title}. {source}"

    # Rename files to match the key
    name = os.path.basename(path)
    if name != entry.key + ".bib":
        new_name = entry.key + ".bib"
        new_path = path[:-len(name)] + new_name
        os.rename(path, new_path)
        md_path = path[:-3] + "md"
        if os.path.exists(md_path):
            os.rename(md_path, new_path[:-3] + "md")
        path = new_path
        name = new_name

    # Generate corresponding Markdown file
    with open(path[:-3] + "md", "w") as file:
        file.write("---\nhide:\n  - toc\n---\n\n")
        file.write(WARN + "\n\n")
        file.write(f"# {title}\n\n")
        file.write(f"**Reference:** {ref}\n\n")
        file.write('<div class="grid" markdown="1">\n\n')
        file.write(f"**Entry Key:** `#!tex \\cite{{{entry.key}}}`\n\n")
        file.write(f"**Entry Type:** `@{entry.entry_type}`\n\n")
        file.write("</div>\n\n")

        # Generate code for download link
        down = '{download="' + name + '"}'
        file.write(f"[:material-download: Download .bib file]({name}){down}\n\n")
        file.write("## Metadata\n\n")

        # Render the BiBTeX fields as a table
        contents = ""
        file.write("Field | Value\n------|------\n")
        for fkey, field in entry.fields_dict.items():
            if fkey != "contents":
                file.write(f"{fkey} | {field.value}\n")
            else:
                # Get the index of the left brace
                pattern = r"^\s*contents\s*=\s*{"
                match = re.search(pattern, entry.raw, re.MULTILINE)
                col = len(match.group())
                # Remove leading whitespace from every line
                lines = field.value.splitlines()
                for i in range(1, len(lines)):
                    line = lines[i]
                    beg = 0
                    while beg < len(line) and beg < col and line[beg] == " ":
                        beg += 1
                    lines[i] = line[beg:]
                contents = "\n".join(lines)

        # Write contents section for activities
        if contents:
            file.write("\n## Contents\n\n")
            file.write(contents + "\n")


def main():
    """Find and parse every bib file."""
    for path in glob.glob("docs/**/*.bib", recursive=True):
        print(path)
        library = bibtexparser.parse_file(path)
        n = len(library.failed_blocks)
        if n > 0:
            print(f"Error: {n} blocks failed to parse")
            return
        n = len(library.entries)
        if n != 1:
            print(f"Error: Found {n} entries (should be 1)")
        for entry in library.entries:
            bib2md(path, entry)


if __name__ == "__main__":
    main()
