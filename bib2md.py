"""Parse all BibTeX files and generate Markdown for each entry."""

import bibtexparser
import glob
import os
import re

WARN = "<!-- DO NOT EDIT THIS FILE (automatically generated by bib2md.py) -->"


def parse_entry(path):
    """Parse the given bib file and return the entry."""

    # Abort if the file format is incorrect
    library = bibtexparser.parse_file(path)
    n = len(library.failed_blocks)
    if n > 0:
        raise ValueError(f"{n} blocks failed to parse")
    n = len(library.entries)
    if n != 1:
        raise ValueError(f"{n} entries found (not 1)")
    return library.entries[0]


def reformat_authors(author_string):
    """Convert author string to "First Last" format, separated by commas."""
    authors = author_string.split(" and ")
    reformatted = []
    for author in authors:
        if "," in author:
            last, first = [part.strip() for part in author.split(",", 1)]
            reformatted.append(f"{first} {last}")
        else:
            # Already in "First Last" format
            reformatted.append(author.strip())
    return ", ".join(reformatted)


def abbreviate(url):
    """Shorten the URL for better text wrapping."""
    pos = url.index("/", 8)
    return url[:pos+1] + "..."


def get_fields(entry):
    """Extract common fields used in references and summary tables."""
    fields = entry.fields_dict
    author = fields["author"].value
    author = reformat_authors(author)
    year = fields["year"].value
    title = fields["title"].value

    # Get the source in order of priority
    source = None
    for fkey in ["series", "booktitle", "journal", "publisher", "howpublished"]:
        if fkey in fields:
            source = fields[fkey].value
            break

    # Default to short url if not found
    if not source:
        url = fields["url"].value
        abbr = abbreviate(url)
        source = f"[{abbr}]({url})"

    return author, year, title, source


def write_entry(entry, out):
    """Output the given entry in Markdown format."""

    # Write the "Abstract" section if present
    field = entry.fields_dict.get("abstract")
    if field:
        out.write("\n## Abstract\n\n")
        out.write(field.value + "\n")

    # Write the "Contents" section if present
    field = entry.fields_dict.get("contents")
    if field:

        # Get the index after the left brace
        pattern = r"^\s*contents\s*=\s*{"
        match = re.search(pattern, entry.raw, re.MULTILINE)
        col = len(match.group())

        # Remove leading whitespace from each line
        lines = field.value.splitlines()
        for i in range(1, len(lines)):
            line = lines[i]
            beg = 0
            while beg < len(line) and beg < col and line[beg] == " ":
                beg += 1
            lines[i] = line[beg:]

        # The resulting lines are Markdown format
        out.write("\n## Contents\n\n")
        out.write("\n".join(lines) + "\n")

    # Write section heading and download link
    out.write("\n## Metadata\n\n")
    name = entry.key + ".bib"
    down = '{download="' + name + '"}'
    out.write(f"[:material-download: Download .bib file]({name}){down}\n\n")

    # Write field-value pairs in table format
    out.write("Field | Value\n------|------\n")
    for fkey, field in entry.fields_dict.items():
        if fkey in ["abstract", "contents"]:
            continue
        out.write(f"{fkey} | ")
        if fkey != "url":
            out.write(f"{field.value}\n")
        else:
            # Abbreviate the URL to allow text wrapping
            url = field.value
            abbr = abbreviate(url)
            out.write(f"[{abbr}]({url})\n")


def gen_md_file(path, entry):
    """Generate a Markdown file for the entry (publication)."""

    # Create a reference format string
    author, year, title, source = get_fields(entry)
    ref = f"{author}. ({year}). {title}."
    if source:
        if entry.entry_type.startswith("in"):
            ref += f" In *{source}*."
        else:
            ref += f" *{source}*."

    # Rename files to match the key
    name = os.path.basename(path)
    if name != entry.key + ".bib":
        new_name = entry.key + ".bib"
        new_path = path[:-len(name)] + new_name
        os.rename(path, new_path)
        md_path = path[:-3] + "md"
        if os.path.exists(md_path):
            os.rename(md_path, new_path[:-3] + "md")
        path = new_path
        name = new_name

    # Generate corresponding Markdown file
    with open(path[:-3] + "md", "w") as file:
        file.write("---\nhide:\n  - toc\n---\n\n")
        file.write(WARN + "\n\n")
        file.write(f"# {title}\n\n")
        file.write(f"**Reference:** {ref}\n\n")
        file.write('<div class="grid" markdown="1">\n\n')
        file.write(f"**Entry Key:** `#!tex \\cite{{{entry.key}}}`\n\n")
        file.write(f"**Entry Type:** `@{entry.entry_type}`\n\n")
        file.write("</div>\n")
        write_entry(entry, file)


def sort_key(item):
    """Sort table entries by (year desc, title)."""
    fields = item[1].fields_dict
    year = int(fields["year"].value)
    title = fields["title"].value
    return (-year, title)


def gen_table(name, entries_dict):
    """Generate a Markdown table for the given entires."""
    path = f"tables/{name}.md"
    with open(path, "w") as file:
        file.write(WARN + "\n")
        prev_dir = None
        items = sorted(entries_dict.items(), key=sort_key)
        for href, entry in items:

            # Subsection for each directory
            idx = href.find("/")
            curr_dir = href[:idx] if idx > -1 else None
            if curr_dir != prev_dir:
                file.write(f"\n## {curr_dir} ")
                file.write("{ data-search-exclude }\n\n")
                prev_dir = curr_dir

            # Bullet list item for each entry
            author, year, title, source = get_fields(entry)
            link = f"[**{title}**]({href})"
            file.write(f"* {link}<br>\n  ")
            file.write(f'<span class="smaller">{author} ({source} {year})</span>\n')


def main():
    """Generate md files and index pages."""
    acts = {}
    pubs = {}

    # Find and parse every bib file
    for path in sorted(glob.glob("docs/**/*.bib", recursive=True)):
        print(path)
        entry = parse_entry(path)
        if path.startswith("docs/research"):
            gen_md_file(path, entry)

            # Relative path from index page
            href = path[14:-3] + "md"
            pubs[href] = entry
        else:
            href = path[16:-3] + "md"
            acts[href] = entry

    # Generate the index pages
    gen_table("activities", acts)
    gen_table("research", pubs)


if __name__ == "__main__":
    main()
